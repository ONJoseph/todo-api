"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorToResponse = exports.mapCompactResponse = exports.mapEarlyResponse = exports.mapResponse = exports.cookieToHeader = exports.parseSetCookies = exports.isNotEmpty = void 0;
// @ts-ignore
const cookie_1 = require("cookie");
const utils_1 = require("./utils");
const cookie_2 = require("./cookie");
const hasHeaderShorthand = 'toJSON' in new Headers();
const isNotEmpty = (obj) => {
    for (const x in obj)
        return true;
    return false;
};
exports.isNotEmpty = isNotEmpty;
const parseSetCookies = (headers, setCookie) => {
    if (!headers || !Array.isArray(setCookie))
        return headers;
    headers.delete('Set-Cookie');
    for (let i = 0; i < setCookie.length; i++) {
        const index = setCookie[i].indexOf('=');
        headers.append('Set-Cookie', `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`);
    }
    return headers;
};
exports.parseSetCookies = parseSetCookies;
const cookieToHeader = (cookies) => {
    if (!cookies || typeof cookies !== 'object' || !(0, exports.isNotEmpty)(cookies))
        return undefined;
    const set = [];
    for (const [key, property] of Object.entries(cookies)) {
        if (!key || !property)
            continue;
        if (Array.isArray(property.value)) {
            for (let i = 0; i < property.value.length; i++) {
                let value = property.value[i];
                if (value === undefined || value === null)
                    continue;
                if (typeof value === 'object')
                    value = JSON.stringify(value);
                set.push((0, cookie_1.serialize)(key, value, property));
            }
        }
        else {
            let value = property.value;
            if (value === undefined || value === null)
                continue;
            if (typeof value === 'object')
                value = JSON.stringify(value);
            set.push((0, cookie_1.serialize)(key, property.value, property));
        }
    }
    if (set.length === 0)
        return undefined;
    if (set.length === 1)
        return set[0];
    return set;
};
exports.cookieToHeader = cookieToHeader;
const mapResponse = (response, set) => {
    if ((0, exports.isNotEmpty)(set.headers) ||
        set.status !== 200 ||
        set.redirect ||
        set.cookie) {
        if (typeof set.status === 'string')
            set.status = utils_1.StatusMap[set.status];
        if (set.redirect) {
            set.headers.Location = set.redirect;
            if (!set.status || set.status < 300 || set.status >= 400)
                set.status = 302;
        }
        if (set.cookie && (0, exports.isNotEmpty)(set.cookie))
            set.headers['Set-Cookie'] = (0, exports.cookieToHeader)(set.cookie);
        if (set.headers['Set-Cookie'] &&
            Array.isArray(set.headers['Set-Cookie']))
            set.headers = (0, exports.parseSetCookies)(new Headers(set.headers), set.headers['Set-Cookie']);
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response, {
                    status: set.status,
                    headers: set.headers
                });
            case 'Object':
            case 'Array':
                return Response.json(response, set);
            case undefined:
                if (!response)
                    return new Response('', set);
                return Response.json(response, set);
            case 'Response':
                const inherits = { ...set.headers };
                if (hasHeaderShorthand)
                    set.headers = response.headers.toJSON();
                else
                    for (const [key, value] of response.headers.entries())
                        if (key in set.headers)
                            set.headers[key] = value;
                for (const key in inherits)
                    response.headers.append(key, inherits[key]);
                return response;
            case 'Error':
                return (0, exports.errorToResponse)(response, set);
            case 'Promise':
                // @ts-ignore
                return response.then((x) => (0, exports.mapResponse)(x, set));
            case 'Function':
                return (0, exports.mapResponse)(response(), set);
            case 'Number':
            case 'Boolean':
                return new Response(response.toString(), set);
            case 'Cookie':
                if (response instanceof cookie_2.Cookie)
                    return new Response(response.value, set);
                return new Response(response?.toString(), set);
            default:
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123) {
                    if (!set.headers['Content-Type'])
                        set.headers['Content-Type'] = 'application/json';
                    return new Response(JSON.stringify(response), set);
                }
                return new Response(r, set);
        }
    }
    else
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response);
            case 'Object':
            case 'Array':
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case undefined:
                if (!response)
                    return new Response('');
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case 'Response':
                return response;
            case 'Error':
                return (0, exports.errorToResponse)(response, set);
            case 'Promise':
                // @ts-ignore
                return response.then((x) => {
                    const r = (0, exports.mapCompactResponse)(x);
                    if (r !== undefined)
                        return r;
                    return new Response('');
                });
            // ? Maybe response or Blob
            case 'Function':
                return (0, exports.mapCompactResponse)(response());
            case 'Number':
            case 'Boolean':
                return new Response(response.toString());
            case 'Cookie':
                if (response instanceof cookie_2.Cookie)
                    return new Response(response.value, set);
                return new Response(response?.toString(), set);
            default:
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123)
                    return new Response(JSON.stringify(response), {
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                return new Response(r);
        }
};
exports.mapResponse = mapResponse;
const mapEarlyResponse = (response, set) => {
    if (response === undefined || response === null)
        return;
    if ((0, exports.isNotEmpty)(set.headers) ||
        set.status !== 200 ||
        set.redirect ||
        set.cookie) {
        if (typeof set.status === 'string')
            set.status = utils_1.StatusMap[set.status];
        if (set.redirect) {
            set.headers.Location = set.redirect;
            if (!set.status || set.status < 300 || set.status >= 400)
                set.status = 302;
        }
        if (set.cookie && (0, exports.isNotEmpty)(set.cookie))
            set.headers['Set-Cookie'] = (0, exports.cookieToHeader)(set.cookie);
        if (set.headers['Set-Cookie'] &&
            Array.isArray(set.headers['Set-Cookie']))
            set.headers = (0, exports.parseSetCookies)(new Headers(set.headers), set.headers['Set-Cookie']);
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response, set);
            case 'Object':
            case 'Array':
                return Response.json(response, set);
            case undefined:
                if (!response)
                    return;
                return Response.json(response, set);
            case 'Response':
                const inherits = Object.assign({}, set.headers);
                if (hasHeaderShorthand)
                    // @ts-ignore
                    set.headers = response.headers.toJSON();
                else
                    for (const [key, value] of response.headers.entries())
                        if (!(key in set.headers))
                            set.headers[key] = value;
                for (const key in inherits)
                    response.headers.append(key, inherits[key]);
                if (response.status !== set.status)
                    set.status = response.status;
                return response;
            case 'Promise':
                // @ts-ignore
                return response.then((x) => {
                    const r = (0, exports.mapEarlyResponse)(x, set);
                    if (r !== undefined)
                        return r;
                    return;
                });
            case 'Error':
                return (0, exports.errorToResponse)(response, set);
            case 'Function':
                return (0, exports.mapEarlyResponse)(response(), set);
            case 'Number':
            case 'Boolean':
                return new Response(response.toString(), set);
            case 'Cookie':
                if (response instanceof cookie_2.Cookie)
                    return new Response(response.value, set);
                return new Response(response?.toString(), set);
            default:
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123) {
                    if (!set.headers['Content-Type'])
                        set.headers['Content-Type'] = 'application/json';
                    return new Response(JSON.stringify(response), set);
                }
                return new Response(r, set);
        }
    }
    else
        switch (response?.constructor?.name) {
            case 'String':
            case 'Blob':
                return new Response(response);
            case 'Object':
            case 'Array':
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case undefined:
                if (!response)
                    return new Response('');
                return new Response(JSON.stringify(response), {
                    headers: {
                        'content-type': 'application/json'
                    }
                });
            case 'Response':
                return response;
            case 'Promise':
                // @ts-ignore
                return response.then((x) => {
                    const r = (0, exports.mapEarlyResponse)(x, set);
                    if (r !== undefined)
                        return r;
                    return;
                });
            case 'Error':
                return (0, exports.errorToResponse)(response, set);
            case 'Function':
                return (0, exports.mapCompactResponse)(response());
            case 'Number':
            case 'Boolean':
                return new Response(response.toString());
            case 'Cookie':
                if (response instanceof cookie_2.Cookie)
                    return new Response(response.value, set);
                return new Response(response?.toString(), set);
            default:
                const r = JSON.stringify(response);
                if (r.charCodeAt(0) === 123)
                    return new Response(JSON.stringify(response), {
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                return new Response(r);
        }
};
exports.mapEarlyResponse = mapEarlyResponse;
const mapCompactResponse = (response) => {
    switch (response?.constructor?.name) {
        case 'String':
        case 'Blob':
            return new Response(response);
        case 'Object':
        case 'Array':
            return new Response(JSON.stringify(response), {
                headers: {
                    'content-type': 'application/json'
                }
            });
        case undefined:
            if (!response)
                return new Response('');
            return new Response(JSON.stringify(response), {
                headers: {
                    'content-type': 'application/json'
                }
            });
        case 'Response':
            return response;
        case 'Error':
            return (0, exports.errorToResponse)(response);
        case 'Promise':
            // @ts-ignore
            return response.then((x) => {
                const r = (0, exports.mapCompactResponse)(x);
                if (r !== undefined)
                    return r;
                return new Response('');
            });
        // ? Maybe response or Blob
        case 'Function':
            return (0, exports.mapCompactResponse)(response());
        case 'Number':
        case 'Boolean':
            return new Response(response.toString());
        default:
            const r = JSON.stringify(response);
            if (r.charCodeAt(0) === 123)
                return new Response(JSON.stringify(response), {
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
            return new Response(r);
    }
};
exports.mapCompactResponse = mapCompactResponse;
const errorToResponse = (error, set) => new Response(JSON.stringify({
    name: error?.name,
    message: error?.message,
    cause: error?.cause
}), {
    status: set?.status !== 200 ? set?.status ?? 500 : 500,
    headers: set?.headers
});
exports.errorToResponse = errorToResponse;
