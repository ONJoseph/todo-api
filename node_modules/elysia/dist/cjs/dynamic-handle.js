"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDynamicErrorHandler = exports.createDynamicHandler = void 0;
const handler_1 = require("./handler");
const error_1 = require("./error");
const fast_querystring_1 = require("fast-querystring");
const utils_1 = require("./utils");
const cookie_1 = require("./cookie");
const createDynamicHandler = (app) => async (request) => {
    const set = {
        cookie: {},
        status: 200,
        headers: {}
    };
    let context;
    // @ts-ignore
    if (app.decorators) {
        // @ts-ignore
        context = app.decorators;
        context.request = request;
        context.set = set;
        context.store = app.store;
    }
    else {
        context = {
            set,
            store: app.store,
            request
        };
    }
    const url = request.url, s = url.indexOf('/', 11), q = url.indexOf('?', s + 1), path = q === -1 ? url.substring(s) : url.substring(s, q);
    try {
        for (let i = 0; i < app.event.request.length; i++) {
            // @ts-ignore
            const onRequest = app.event.request[i];
            let response = onRequest(context);
            if (response instanceof Promise)
                response = await response;
            response = (0, handler_1.mapEarlyResponse)(response, set);
            if (response)
                return response;
        }
        const handler = 
        // @ts-ignore
        app.dynamicRouter.find(request.method, path) ??
            // @ts-ignore
            app.dynamicRouter.find('ALL', path);
        if (!handler)
            throw new error_1.NotFoundError();
        const { handle, hooks, validator, content } = handler.store;
        let body;
        if (request.method !== 'GET' && request.method !== 'HEAD') {
            if (content) {
                switch (content) {
                    case 'application/json':
                        body = await request.json();
                        break;
                    case 'text/plain':
                        body = await request.text();
                        break;
                    case 'application/x-www-form-urlencoded':
                        body = (0, fast_querystring_1.parse)(await request.text());
                        break;
                    case 'application/octet-stream':
                        body = await request.arrayBuffer();
                        break;
                    case 'multipart/form-data':
                        body = {};
                        const form = await request.formData();
                        for (const key of form.keys()) {
                            if (body[key])
                                continue;
                            const value = form.getAll(key);
                            if (value.length === 1)
                                body[key] = value[0];
                            else
                                body[key] = value;
                        }
                        break;
                }
            }
            else {
                let contentType = request.headers.get('content-type');
                if (contentType) {
                    const index = contentType.indexOf(';');
                    if (index !== -1)
                        contentType = contentType.slice(0, index);
                    for (let i = 0; i < app.event.parse.length; i++) {
                        // @ts-ignore
                        let temp = app.event.parse[i](context, contentType);
                        if (temp instanceof Promise)
                            temp = await temp;
                        if (temp) {
                            body = temp;
                            break;
                        }
                    }
                    // body might be empty string thus can't use !body
                    if (body === undefined) {
                        switch (contentType) {
                            case 'application/json':
                                body = await request.json();
                                break;
                            case 'text/plain':
                                body = await request.text();
                                break;
                            case 'application/x-www-form-urlencoded':
                                body = (0, fast_querystring_1.parse)(await request.text());
                                break;
                            case 'application/octet-stream':
                                body = await request.arrayBuffer();
                                break;
                            case 'multipart/form-data':
                                body = {};
                                const form = await request.formData();
                                for (const key of form.keys()) {
                                    if (body[key])
                                        continue;
                                    const value = form.getAll(key);
                                    if (value.length === 1)
                                        body[key] = value[0];
                                    else
                                        body[key] = value;
                                }
                                break;
                        }
                    }
                }
            }
        }
        context.body = body;
        // @ts-ignore
        context.params = handler?.params || undefined;
        context.query = q === -1 ? {} : (0, fast_querystring_1.parse)(url.substring(q + 1));
        context.headers = {};
        for (const [key, value] of request.headers.entries())
            context.headers[key] = value;
        // @ts-ignore
        const cookieMeta = validator?.cookie?.schema;
        context.cookie = await (0, cookie_1.parseCookie)(context.set, context.headers.cookie, cookieMeta
            ? {
                secret: cookieMeta.secrets !== undefined
                    ? typeof cookieMeta.secrets === 'string'
                        ? cookieMeta.secrets
                        : cookieMeta.secrets.join(',')
                    : undefined,
                sign: cookieMeta.sign === true
                    ? true
                    : cookieMeta.sign !== undefined
                        ? typeof cookieMeta.sign === 'string'
                            ? cookieMeta.sign
                            : cookieMeta.sign.join(',')
                        : undefined
            }
            : undefined);
        for (let i = 0; i < hooks.transform.length; i++) {
            const operation = hooks.transform[i](context);
            // @ts-ignore
            if (hooks.transform[i].$elysia === 'derive') {
                if (operation instanceof Promise)
                    Object.assign(context, await operation);
                else
                    Object.assign(context, operation);
            }
            else if (operation instanceof Promise)
                await operation;
        }
        if (validator) {
            if (validator.headers) {
                const _header = {};
                for (const key in request.headers)
                    _header[key] = request.headers.get(key);
                if (validator.headers.Check(_header) === false)
                    throw new error_1.ValidationError('header', validator.headers, _header);
            }
            if (validator.params?.Check(context.params) === false)
                throw new error_1.ValidationError('params', validator.params, context.params);
            if (validator.query?.Check(context.query) === false)
                throw new error_1.ValidationError('query', validator.query, context.query);
            if (validator.cookie) {
                const cookieValue = {};
                for (const [key, value] of Object.entries(context.cookie))
                    cookieValue[key] = value.value;
                if (validator.cookie?.Check(cookieValue) === false)
                    throw new error_1.ValidationError('cookie', validator.cookie, cookieValue);
            }
            if (validator.body?.Check(body) === false)
                throw new error_1.ValidationError('body', validator.body, body);
        }
        for (let i = 0; i < hooks.beforeHandle.length; i++) {
            let response = hooks.beforeHandle[i](context);
            if (response instanceof Promise)
                response = await response;
            // `false` is a falsey value, check for undefined instead
            if (response !== undefined) {
                ;
                context.response = response;
                for (let i = 0; i < hooks.afterHandle.length; i++) {
                    let newResponse = hooks.afterHandle[i](context);
                    if (newResponse instanceof Promise)
                        newResponse = await newResponse;
                    if (newResponse)
                        response = newResponse;
                }
                const result = (0, handler_1.mapEarlyResponse)(response, context.set);
                if (result)
                    return result;
            }
        }
        let response = handle(context);
        if (response instanceof Promise)
            response = await response;
        if (!hooks.afterHandle.length) {
            const responseValidator = validator?.response?.[response.status];
            if (responseValidator?.Check(response) === false)
                throw new error_1.ValidationError('response', responseValidator, response);
        }
        else {
            ;
            context.response = response;
            for (let i = 0; i < hooks.afterHandle.length; i++) {
                let newResponse = hooks.afterHandle[i](context);
                if (newResponse instanceof Promise)
                    newResponse = await newResponse;
                const result = (0, handler_1.mapEarlyResponse)(newResponse, context.set);
                if (result !== undefined) {
                    const responseValidator = validator?.response?.[response.status];
                    if (responseValidator?.Check(result) === false)
                        throw new error_1.ValidationError('response', responseValidator, result);
                    return result;
                }
            }
        }
        if (context.set.cookie && cookieMeta?.sign) {
            const secret = !cookieMeta.secrets
                ? undefined
                : typeof cookieMeta.secrets === 'string'
                    ? cookieMeta.secrets
                    : cookieMeta.secrets[0];
            if (cookieMeta.sign === true)
                for (const [key, cookie] of Object.entries(context.set.cookie))
                    context.set.cookie[key].value = await (0, utils_1.signCookie)(cookie.value, '${secret}');
            else
                for (const name of cookieMeta.sign) {
                    if (!(name in cookieMeta.properties))
                        continue;
                    if (context.set.cookie[name]?.value) {
                        context.set.cookie[name].value = await (0, utils_1.signCookie)(context.set.cookie[name].value, secret);
                    }
                }
        }
        return (0, handler_1.mapResponse)(response, context.set);
    }
    catch (error) {
        if (error.status)
            set.status = error.status;
        // @ts-ignore
        return app.handleError(context, error);
    }
    finally {
        // @ts-ignore
        for (const onResponse of app.event.onResponse)
            await onResponse(context);
    }
};
exports.createDynamicHandler = createDynamicHandler;
const createDynamicErrorHandler = (app) => async (context, error) => {
    const errorContext = Object.assign(context, error);
    errorContext.set = context.set;
    // @ts-ignore
    for (let i = 0; i < app.event.error.length; i++) {
        let response = app.event.error[i](errorContext);
        if (response instanceof Promise)
            response = await response;
        if (response !== undefined && response !== null)
            return (0, handler_1.mapResponse)(response, context.set);
    }
    return new Response(typeof error.cause === 'string' ? error.cause : error.message, {
        headers: context.set.headers,
        status: error.status ?? 500
    });
};
exports.createDynamicErrorHandler = createDynamicErrorHandler;
