"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unsignCookie = exports.signCookie = exports.StatusMap = exports.filterGlobalHook = exports.asGlobal = exports.asGlobalHook = exports.mergeLifeCycle = exports.checksum = exports.getResponseSchemaValidator = exports.getSchemaValidator = exports.mergeHook = exports.mergeObjectArray = exports.mergeCookie = exports.mergeDeep = void 0;
const typebox_1 = require("@sinclair/typebox");
const value_1 = require("@sinclair/typebox/value");
const compiler_1 = require("@sinclair/typebox/compiler");
const handler_1 = require("./handler");
const isObject = (item) => item && typeof item === 'object' && !Array.isArray(item);
const isClass = (v) => (typeof v === 'function' && /^\s*class\s+/.test(v.toString())) ||
    // Handle import * as Sentry from '@sentry/bun'
    // This also handle [object Date], [object Array]
    // and FFI value like [object Prisma]
    v.toString().startsWith('[object ') ||
    // If object prototype is not pure, then probably a class-like object
    (0, handler_1.isNotEmpty)(Object.getPrototypeOf(v));
const mergeDeep = (target, source, { skipKeys } = {}) => {
    if (isObject(target) && isObject(source))
        for (const [key, value] of Object.entries(source)) {
            if (skipKeys?.includes(key))
                continue;
            if (!isObject(value)) {
                target[key] = value;
                continue;
            }
            if (!(key in target)) {
                target[key] = value;
                continue;
            }
            if (isClass(value)) {
                target[key] = value;
                continue;
            }
            target[key] = (0, exports.mergeDeep)(target[key], value);
        }
    return target;
};
exports.mergeDeep = mergeDeep;
const mergeCookie = (target, source) => (0, exports.mergeDeep)(target, source, {
    skipKeys: ['properties']
});
exports.mergeCookie = mergeCookie;
const mergeObjectArray = (a, b) => {
    // ! Must copy to remove side-effect
    const array = [...(Array.isArray(a) ? a : [a])];
    const checksums = [];
    for (const item of array) {
        // @ts-ignore
        if (item.$elysiaChecksum)
            // @ts-ignore
            checksums.push(item.$elysiaChecksum);
    }
    for (const item of Array.isArray(b) ? b : [b]) {
        // @ts-ignore
        if (!checksums.includes(item?.$elysiaChecksum))
            array.push(item);
    }
    return array;
};
exports.mergeObjectArray = mergeObjectArray;
const mergeHook = (a, b) => {
    return {
        // Merge local hook first
        // @ts-ignore
        body: b?.body ?? a?.body,
        // @ts-ignore
        headers: b?.headers ?? a?.headers,
        // @ts-ignore
        params: b?.params ?? a?.params,
        // @ts-ignore
        query: b?.query ?? a?.query,
        // @ts-ignore
        response: b?.response ?? a?.response,
        type: a?.type || b?.type,
        detail: (0, exports.mergeDeep)(
        // @ts-ignore
        b?.detail ?? {}, 
        // @ts-ignore
        a?.detail ?? {}),
        parse: (0, exports.mergeObjectArray)(a?.parse ?? [], b?.parse ?? []),
        transform: (0, exports.mergeObjectArray)(a?.transform ?? [], b?.transform ?? []),
        beforeHandle: (0, exports.mergeObjectArray)(a?.beforeHandle ?? [], b?.beforeHandle ?? []),
        afterHandle: (0, exports.mergeObjectArray)(a?.afterHandle ?? [], b?.afterHandle ?? []),
        onResponse: (0, exports.mergeObjectArray)(a?.onResponse ?? [], b?.onResponse ?? []),
        trace: (0, exports.mergeObjectArray)(a?.trace ?? [], b?.trace ?? []),
        error: (0, exports.mergeObjectArray)(a?.error ?? [], b?.error ?? [])
    };
};
exports.mergeHook = mergeHook;
const getSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const schema = typeof s === 'string' ? models[s] : s;
    // @ts-ignore
    if (schema.type === 'object' && 'additionalProperties' in schema === false)
        schema.additionalProperties = additionalProperties;
    if (dynamic)
        return {
            schema,
            references: '',
            checkFunc: () => { },
            code: '',
            Check: (value) => value_1.Value.Check(schema, value),
            Errors: (value) => value_1.Value.Errors(schema, value),
            Code: () => ''
        };
    return compiler_1.TypeCompiler.Compile(schema);
};
exports.getSchemaValidator = getSchemaValidator;
const getResponseSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s;
    const compile = (schema) => {
        if (dynamic)
            return {
                schema,
                references: '',
                checkFunc: () => { },
                code: '',
                Check: (value) => value_1.Value.Check(schema, value),
                Errors: (value) => value_1.Value.Errors(schema, value),
                Code: () => ''
            };
        return compiler_1.TypeCompiler.Compile(schema);
    };
    if (typebox_1.Kind in maybeSchemaOrRecord) {
        if ('additionalProperties' in maybeSchemaOrRecord === false)
            maybeSchemaOrRecord.additionalProperties = additionalProperties;
        return {
            200: compile(maybeSchemaOrRecord)
        };
    }
    const record = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
        const maybeNameOrSchema = maybeSchemaOrRecord[+status];
        if (typeof maybeNameOrSchema === 'string') {
            if (maybeNameOrSchema in models) {
                const schema = models[maybeNameOrSchema];
                schema.type === 'object' &&
                    'additionalProperties' in schema === false;
                // Inherits model maybe already compiled
                record[+status] = typebox_1.Kind in schema ? compile(schema) : schema;
            }
            return undefined;
        }
        if (maybeNameOrSchema.type === 'object' &&
            'additionalProperties' in maybeNameOrSchema === false)
            maybeNameOrSchema.additionalProperties = additionalProperties;
        // Inherits model maybe already compiled
        record[+status] =
            typebox_1.Kind in maybeNameOrSchema
                ? compile(maybeNameOrSchema)
                : maybeNameOrSchema;
    });
    return record;
};
exports.getResponseSchemaValidator = getResponseSchemaValidator;
// https://stackoverflow.com/a/52171480
const checksum = (s) => {
    let h = 9;
    for (let i = 0; i < s.length;)
        h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
    return (h = h ^ (h >>> 9));
};
exports.checksum = checksum;
const mergeLifeCycle = (a, b, checksum) => {
    const injectChecksum = (x) => {
        if (checksum)
            // @ts-ignore
            x.$elysiaChecksum = checksum;
        return x;
    };
    return {
        start: (0, exports.mergeObjectArray)(a.start, ('start' in b ? b.start ?? [] : []).map(injectChecksum)),
        request: (0, exports.mergeObjectArray)(a.request, ('request' in b ? b.request ?? [] : []).map(injectChecksum)),
        parse: (0, exports.mergeObjectArray)(a.parse, 'parse' in b ? b?.parse ?? [] : undefined ?? []).map(injectChecksum),
        transform: (0, exports.mergeObjectArray)(a.transform, (b?.transform ?? []).map(injectChecksum)),
        beforeHandle: (0, exports.mergeObjectArray)(a.beforeHandle, (b?.beforeHandle ?? []).map(injectChecksum)),
        afterHandle: (0, exports.mergeObjectArray)(a.afterHandle, (b?.afterHandle ?? []).map(injectChecksum)),
        onResponse: (0, exports.mergeObjectArray)(a.onResponse, (b?.onResponse ?? []).map(injectChecksum)),
        trace: (0, exports.mergeObjectArray)(a.trace, ('trace' in b ? b.trace ?? [] : []).map(injectChecksum)),
        error: (0, exports.mergeObjectArray)(a.error, (b?.error ?? []).map(injectChecksum)),
        stop: (0, exports.mergeObjectArray)(a.stop, ('stop' in b ? b.stop ?? [] : []).map(injectChecksum))
    };
};
exports.mergeLifeCycle = mergeLifeCycle;
const asGlobalHook = (hook, inject = true) => {
    return {
        // rest is validator
        ...hook,
        type: hook?.type,
        detail: hook?.detail,
        parse: (0, exports.asGlobal)(hook?.parse, inject),
        transform: (0, exports.asGlobal)(hook?.transform, inject),
        beforeHandle: (0, exports.asGlobal)(hook?.beforeHandle, inject),
        afterHandle: (0, exports.asGlobal)(hook?.afterHandle, inject),
        onResponse: (0, exports.asGlobal)(hook?.onResponse, inject),
        error: (0, exports.asGlobal)(hook?.error, inject)
    };
};
exports.asGlobalHook = asGlobalHook;
const asGlobal = (fn, inject = true) => {
    if (!fn)
        return fn;
    if (typeof fn === 'function') {
        if (inject)
            // @ts-ignore
            fn.$elysiaHookType = 'global';
        // @ts-ignore
        else
            fn.$elysiaHookType = undefined;
        return fn;
    }
    return fn.map((x) => {
        if (inject)
            // @ts-ignore
            x.$elysiaHookType = 'global';
        // @ts-ignore
        else
            x.$elysiaHookType = undefined;
        return x;
    });
};
exports.asGlobal = asGlobal;
const filterGlobal = (fn) => {
    if (!fn)
        return fn;
    if (typeof fn === 'function') {
        // @ts-ignore
        return fn.$elysiaHookType === 'global' ? fn : undefined;
    }
    // @ts-ignore
    return fn.filter((x) => x.$elysiaHookType === 'global');
};
const filterGlobalHook = (hook) => {
    return {
        // rest is validator
        ...hook,
        type: hook?.type,
        detail: hook?.detail,
        parse: filterGlobal(hook?.parse),
        transform: filterGlobal(hook?.transform),
        beforeHandle: filterGlobal(hook?.beforeHandle),
        afterHandle: filterGlobal(hook?.afterHandle),
        onResponse: filterGlobal(hook?.onResponse),
        error: filterGlobal(hook?.error)
    };
};
exports.filterGlobalHook = filterGlobalHook;
exports.StatusMap = {
    Continue: 100,
    'Switching Protocols': 101,
    Processing: 102,
    'Early Hints': 103,
    OK: 200,
    Created: 201,
    Accepted: 202,
    'Non-Authoritative Information': 203,
    'No Content': 204,
    'Reset Content': 205,
    'Partial Content': 206,
    'Multi-Status': 207,
    'Already Reported': 208,
    'Multiple Choices': 300,
    'Moved Permanently': 301,
    Found: 302,
    'See Other': 303,
    'Not Modified': 304,
    'Temporary Redirect': 307,
    'Permanent Redirect': 308,
    'Bad Request': 400,
    Unauthorized: 401,
    'Payment Required': 402,
    Forbidden: 403,
    'Not Found': 404,
    'Method Not Allowed': 405,
    'Not Acceptable': 406,
    'Proxy Authentication Required': 407,
    'Request Timeout': 408,
    Conflict: 409,
    Gone: 410,
    'Length Required': 411,
    'Precondition Failed': 412,
    'Payload Too Large': 413,
    'URI Too Long': 414,
    'Unsupported Media Type': 415,
    'Range Not Satisfiable': 416,
    'Expectation Failed': 417,
    "I'm a teapot": 418,
    'Misdirected Request': 421,
    'Unprocessable Content': 422,
    Locked: 423,
    'Failed Dependency': 424,
    'Too Early': 425,
    'Upgrade Required': 426,
    'Precondition Required': 428,
    'Too Many Requests': 429,
    'Request Header Fields Too Large': 431,
    'Unavailable For Legal Reasons': 451,
    'Internal Server Error': 500,
    'Not Implemented': 501,
    'Bad Gateway': 502,
    'Service Unavailable': 503,
    'Gateway Timeout': 504,
    'HTTP Version Not Supported': 505,
    'Variant Also Negotiates': 506,
    'Insufficient Storage': 507,
    'Loop Detected': 508,
    'Not Extended': 510,
    'Network Authentication Required': 511
};
const signCookie = async (val, secret) => {
    if (typeof val !== 'string')
        throw new TypeError('Cookie value must be provided as a string.');
    if (secret === null)
        throw new TypeError('Secret key must be provided.');
    const encoder = new TextEncoder();
    const secretKey = await crypto.subtle.importKey('raw', encoder.encode(secret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
    const hmacBuffer = await crypto.subtle.sign('HMAC', secretKey, encoder.encode(val));
    const hmacArray = Array.from(new Uint8Array(hmacBuffer));
    const digest = btoa(String.fromCharCode(...hmacArray));
    return `${val}.${digest.replace(/=+$/, '')}`;
};
exports.signCookie = signCookie;
const unsignCookie = async (input, secret) => {
    if (typeof input !== 'string')
        throw new TypeError('Signed cookie string must be provided.');
    if (null === secret)
        throw new TypeError('Secret key must be provided.');
    const tentativeValue = input.slice(0, input.lastIndexOf('.'));
    const expectedInput = await (0, exports.signCookie)(tentativeValue, secret);
    return expectedInput === input ? tentativeValue : false;
};
exports.unsignCookie = unsignCookie;
