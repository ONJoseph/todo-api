"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.t = exports.ElysiaType = void 0;
const system_1 = require("@sinclair/typebox/system");
const typebox_1 = require("@sinclair/typebox");
Object.defineProperty(exports, "t", { enumerable: true, get: function () { return typebox_1.Type; } });
try {
    system_1.TypeSystem.Format('email', (value) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(value));
    system_1.TypeSystem.Format('uuid', (value) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value));
    system_1.TypeSystem.Format('date', (value) => !Number.isNaN(new Date(value).getTime()));
    system_1.TypeSystem.Format('date-time', (value) => !Number.isNaN(new Date(value).getTime()));
}
catch (error) {
    // Not empty
}
const parseFileUnit = (size) => {
    if (typeof size === 'string')
        switch (size.slice(-1)) {
            case 'k':
                return +size.slice(0, size.length - 1) * 1024;
            case 'm':
                return +size.slice(0, size.length - 1) * 1048576;
            default:
                return +size;
        }
    return size;
};
const validateFile = (options, value) => {
    if (!(value instanceof Blob))
        return false;
    if (options.minSize && value.size < parseFileUnit(options.minSize))
        return false;
    if (options.maxSize && value.size > parseFileUnit(options.maxSize))
        return false;
    if (options.extension)
        if (typeof options.extension === 'string') {
            if (!value.type.startsWith(options.extension))
                return false;
        }
        else {
            for (let i = 0; i < options.extension.length; i++)
                if (value.type.startsWith(options.extension[i]))
                    return true;
            return false;
        }
    return true;
};
const Files = system_1.TypeSystem.Type('Files', (options, value) => {
    if (!Array.isArray(value))
        return validateFile(options, value);
    if (options.minItems && value.length < options.minItems)
        return false;
    if (options.maxItems && value.length > options.maxItems)
        return false;
    for (let i = 0; i < value.length; i++)
        if (!validateFile(options, value[i]))
            return false;
    return true;
});
typebox_1.FormatRegistry.Set('numeric', (value) => !isNaN(+value));
typebox_1.FormatRegistry.Set('ObjectString', (value) => {
    let start = value.charCodeAt(0);
    // If starts with ' ', '\t', '\n', then trim first
    if (start === 9 || start === 10 || start === 32)
        start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
        return false;
    try {
        JSON.parse(value);
        return true;
    }
    catch {
        return false;
    }
});
exports.ElysiaType = {
    Numeric: (property) => typebox_1.Type.Transform(typebox_1.Type.Union([
        typebox_1.Type.String({
            format: 'numeric',
            default: 0
        }),
        typebox_1.Type.Number(property)
    ]))
        .Decode((value) => {
        const number = +value;
        if (isNaN(number))
            return value;
        return number;
    })
        .Encode((value) => value),
    ObjectString: (properties, options) => typebox_1.Type.Transform(typebox_1.Type.Union([
        typebox_1.Type.String({
            format: 'ObjectString',
            default: ''
        }),
        typebox_1.Type.Object(properties, options)
    ]))
        .Decode((value) => {
        if (typeof value === 'string')
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        return value;
    })
        .Encode((value) => JSON.stringify(value)),
    File: system_1.TypeSystem.Type('File', validateFile),
    Files: (options = {}) => typebox_1.Type.Transform(typebox_1.Type.Union([Files(options)]))
        .Decode((value) => {
        if (Array.isArray(value))
            return value;
        return [value];
    })
        .Encode((value) => value),
    Nullable: (schema) => typebox_1.Type.Union([typebox_1.Type.Null(), schema]),
    /**
     * Allow Optional, Nullable and Undefined
     */
    MaybeEmpty: (schema) => typebox_1.Type.Union([typebox_1.Type.Null(), typebox_1.Type.Undefined(), schema]),
    Cookie: (properties, options) => typebox_1.Type.Object(properties, options)
};
typebox_1.Type.ObjectString = exports.ElysiaType.ObjectString;
/**
 * A Numeric string
 *
 * Will be parse to Number
 */
typebox_1.Type.Numeric = exports.ElysiaType.Numeric;
typebox_1.Type.File = (arg = {}) => exports.ElysiaType.File({
    default: 'File',
    ...arg,
    extension: arg?.type,
    type: 'string',
    format: 'binary'
});
typebox_1.Type.Files = (arg = {}) => exports.ElysiaType.Files({
    ...arg,
    elysiaMeta: 'Files',
    default: 'Files',
    extension: arg?.type,
    type: 'array',
    items: {
        ...arg,
        default: 'Files',
        type: 'string',
        format: 'binary'
    }
});
typebox_1.Type.Nullable = (schema) => exports.ElysiaType.Nullable(schema);
typebox_1.Type.MaybeEmpty = exports.ElysiaType.MaybeEmpty;
typebox_1.Type.Cookie = exports.ElysiaType.Cookie;
// type Template =
// 	| string
// 	| number
// 	| bigint
// 	| boolean
// 	| StringConstructor
// 	| NumberConstructor
// 	| undefined
// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>
// 	? (
// 			First extends Readonly<Template[]>
// 				? First[number]
// 				: First extends StringConstructor
// 				? string
// 				: First extends NumberConstructor
// 				? `${number}`
// 				: First
// 	  ) extends infer A
// 		? Rest extends []
// 			? A extends undefined
// 				? NonNullable<A> | ''
// 				: A
// 			: // @ts-ignore
// 			A extends undefined
// 			? `${NonNullable<A>}${Join<Rest>}` | ''
// 			: // @ts-ignore
// 			  `${A}${Join<Rest>}`
// 		: ''
// 	: ''
// const template = <
// 	const T extends Readonly<(Template | Readonly<Template[]>)[]>
// >(
// 	...p: T
// ): Join<T> => {
// 	return a as any
// }
// const create =
// 	<const T extends string>(t: T): ((t: T) => void) =>
// 	(t) =>
// 		t
// const optional = <
// 	const T extends Readonly<(Template | Readonly<Template[]>)[]>
// >(
// 	...p: T
// ): T | undefined => {
// 	return undefined
// }
// template.optional = optional
// const hi = create(
// 	template(
// 		['seminar', 'millennium'],
// 		':',
// 		['Rio', 'Yuuka', 'Noa', 'Koyuki'],
// 		template.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),
// 		template.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),
// 		template.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))
// 	)
// )
// hi(`seminar:Noa,Koyuki,Yuuka`)
// const a = TypeCompiler.Compile(Type.String())
// console.log(v.Decode.toString())
// const T = Type.Transform(v.schema)
// 	.Decode((value) => new Date(value)) // required: number to Date
// 	.Encode((value) => value.getTime()) // required: Date to number
// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)
// const encoded = Value.Encode(T, decoded)
