"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTraceListener = void 0;
const createTraceListener = (reporter, handler) => {
    return async function trace(event) {
        const id = event.id;
        if (event.event === 'request' && event.type === 'begin') {
            const createSignal = () => {
                let resolveHandle;
                let resolveHandleEnd;
                let childIteration = -1;
                const children = [];
                const endChildren = [];
                let resolved = false;
                const handle = new Promise((resolve) => {
                    resolveHandle = (a) => {
                        if (resolved)
                            return;
                        else
                            resolved = true;
                        resolve(a);
                    };
                });
                let resolvedEnd = false;
                const handleEnd = new Promise((resolve) => {
                    resolveHandleEnd = (a) => {
                        if (resolvedEnd)
                            return;
                        else
                            resolvedEnd = true;
                        if (childIteration === -1)
                            childIteration = 0;
                        for (; childIteration < endChildren.length; childIteration++) {
                            // eslint-disable-next-line prefer-const
                            let end;
                            const start = {
                                name: 'anonymous',
                                time: performance.now(),
                                skip: true,
                                end: new Promise((resolve) => {
                                    resolve(end);
                                }),
                                children: []
                            };
                            end = performance.now();
                            children[childIteration](start);
                        }
                        resolve(a);
                    };
                });
                return {
                    signal: handle,
                    consumeChild(event) {
                        switch (event.type) {
                            case 'begin':
                                children[++childIteration]({
                                    name: event.name,
                                    time: event.time,
                                    skip: false,
                                    end: new Promise((resolve) => {
                                        endChildren.push(resolve);
                                    })
                                });
                                break;
                            case 'end':
                                endChildren[childIteration](event.time);
                                break;
                        }
                    },
                    consume(event) {
                        switch (event.type) {
                            case 'begin':
                                const unitsProcess = [];
                                const units = event.unit ?? 0;
                                for (let i = 0; i < units; i++) {
                                    let resolveChild;
                                    unitsProcess.push(new Promise((resolve) => {
                                        resolveChild = resolve;
                                    }));
                                    children.push(resolveChild);
                                }
                                resolveHandle({
                                    // Begin always have name
                                    name: event.name,
                                    time: event.time,
                                    skip: false,
                                    end: handleEnd,
                                    children: unitsProcess
                                });
                                break;
                            case 'end':
                                resolveHandleEnd(event.time);
                                break;
                        }
                    },
                    resolve() {
                        if (resolved && resolvedEnd)
                            return;
                        // eslint-disable-next-line prefer-const
                        let end;
                        const start = {
                            name: 'anonymous',
                            time: performance.now(),
                            skip: true,
                            end: new Promise((resolve) => {
                                resolve(end);
                            }),
                            children: []
                        };
                        end = performance.now();
                        resolveHandle(start);
                        resolveHandleEnd(end);
                    }
                };
            };
            const request = createSignal();
            const parse = createSignal();
            const transform = createSignal();
            const beforeHandle = createSignal();
            const handle = createSignal();
            const afterHandle = createSignal();
            const error = createSignal();
            const response = createSignal();
            request.consume(event);
            const reducer = (event) => {
                if (event.id === id)
                    switch (event.event) {
                        case 'request':
                            request.consume(event);
                            break;
                        case 'request.unit':
                            request.consumeChild(event);
                            break;
                        case 'parse':
                            parse.consume(event);
                            break;
                        case 'parse.unit':
                            parse.consumeChild(event);
                            break;
                        case 'transform':
                            transform.consume(event);
                            break;
                        case 'transform.unit':
                            transform.consumeChild(event);
                            break;
                        case 'beforeHandle':
                            beforeHandle.consume(event);
                            break;
                        case 'beforeHandle.unit':
                            beforeHandle.consumeChild(event);
                            break;
                        case 'handle':
                            handle.consume(event);
                            break;
                        case 'afterHandle':
                            afterHandle.consume(event);
                            break;
                        case 'afterHandle.unit':
                            afterHandle.consumeChild(event);
                            break;
                        case 'error':
                            error.consume(event);
                            break;
                        case 'error.unit':
                            error.consumeChild(event);
                            break;
                        case 'response':
                            if (event.type === 'begin') {
                                request.resolve();
                                parse.resolve();
                                transform.resolve();
                                beforeHandle.resolve();
                                handle.resolve();
                                afterHandle.resolve();
                                error.resolve();
                            }
                            else
                                reporter.off('event', reducer);
                            response.consume(event);
                            break;
                        case 'response.unit':
                            response.consumeChild(event);
                            break;
                    }
            };
            reporter.on('event', reducer);
            await handler({
                id: event.id,
                // @ts-ignore
                context: event.ctx,
                // @ts-ignore
                set: event.ctx?.set,
                // @ts-ignore
                store: event.ctx?.store,
                time: event.time,
                request: request.signal,
                parse: parse.signal,
                transform: transform.signal,
                beforeHandle: beforeHandle.signal,
                handle: handle.signal,
                afterHandle: afterHandle.signal,
                error: error.signal,
                response: response.signal
            });
            reporter.emit(`res${id}`, undefined);
        }
    };
};
exports.createTraceListener = createTraceListener;
