"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCookie = exports.createCookieJar = exports.Cookie = void 0;
// @ts-ignore
const cookie_1 = require("cookie");
const utils_1 = require("./utils");
const error_1 = require("./error");
class Cookie {
    constructor(_value, property = {}) {
        this._value = _value;
        this.property = property;
    }
    get() {
        return this._value;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (typeof value === 'object') {
            if (JSON.stringify(this.value) === JSON.stringify(value))
                return;
        }
        else if (this.value === value)
            return;
        this._value = value;
        this.sync();
    }
    add(config) {
        const updated = Object.assign(this.property, typeof config === 'function'
            ? config(Object.assign(this.property, this.value))
            : config);
        if ('value' in updated) {
            this._value = updated.value;
            delete updated.value;
        }
        this.property = updated;
        return this.sync();
    }
    set(config) {
        const updated = typeof config === 'function'
            ? config(Object.assign(this.property, this.value))
            : config;
        if ('value' in updated) {
            this._value = updated.value;
            delete updated.value;
        }
        this.property = updated;
        return this.sync();
    }
    remove() {
        if (this.value === undefined)
            return;
        this.set({
            value: '',
            expires: new Date()
        });
    }
    get domain() {
        return this.property.domain;
    }
    set domain(value) {
        // @ts-ignore
        if (this.property.domain === value)
            return;
        // @ts-ignore
        this.property.domain = value;
        this.sync();
    }
    get expires() {
        return this.property.expires;
    }
    set expires(value) {
        // @ts-ignore
        if (this.property.expires?.getTime() === value?.getTime())
            return;
        // @ts-ignore
        this.property.expires = value;
        this.sync();
    }
    get httpOnly() {
        return this.property.httpOnly;
    }
    set httpOnly(value) {
        // @ts-ignore
        if (this.property.domain === value)
            return;
        // @ts-ignore
        this.property.httpOnly = value;
        this.sync();
    }
    get maxAge() {
        return this.property.maxAge;
    }
    set maxAge(value) {
        // @ts-ignore
        if (this.property.maxAge === value)
            return;
        // @ts-ignore
        this.property.maxAge = value;
        this.sync();
    }
    get path() {
        return this.property.path;
    }
    set path(value) {
        // @ts-ignore
        if (this.property.path === value)
            return;
        // @ts-ignore
        this.property.path = value;
        this.sync();
    }
    get priority() {
        return this.property.priority;
    }
    set priority(value) {
        // @ts-ignore
        if (this.property.priority === value)
            return;
        // @ts-ignore
        this.property.priority = value;
        this.sync();
    }
    get sameSite() {
        return this.property.sameSite;
    }
    set sameSite(value) {
        // @ts-ignore
        if (this.property.sameSite === value)
            return;
        // @ts-ignore
        this.property.sameSite = value;
        this.sync();
    }
    get secure() {
        return this.property.secure;
    }
    set secure(value) {
        // @ts-ignore
        if (this.property.secure === value)
            return;
        // @ts-ignore
        this.property.secure = value;
        this.sync();
    }
    toString() {
        return typeof this.value === 'object'
            ? JSON.stringify(this.value)
            : this.value?.toString() ?? '';
    }
    sync() {
        if (!this.name || !this.setter)
            return this;
        if (!this.setter.cookie)
            this.setter.cookie = {
                [this.name]: Object.assign(this.property, {
                    value: this.toString()
                })
            };
        else
            this.setter.cookie[this.name] = Object.assign(this.property, {
                value: this.toString()
            });
        return this;
    }
}
exports.Cookie = Cookie;
const createCookieJar = (initial, set, properties) => new Proxy(initial, {
    get(target, key) {
        if (key in target)
            return target[key];
        // @ts-ignore
        const cookie = new Cookie(undefined, properties ? { ...properties } : undefined);
        // @ts-ignore
        cookie.setter = set;
        cookie.name = key;
        // @ts-ignore
        return cookie;
    },
    set(target, key, value) {
        if (!(value instanceof Cookie))
            return false;
        if (!set.cookie)
            set.cookie = {};
        // @ts-ignore
        value.setter = set;
        value.name = key;
        // @ts-ignore
        value.sync();
        target[key] = value;
        return true;
    }
});
exports.createCookieJar = createCookieJar;
const parseCookie = async (set, cookieString, { secret, sign, ...properties } = {}) => {
    if (!cookieString)
        return (0, exports.createCookieJar)({}, set, properties);
    const jar = {};
    const isStringKey = typeof secret === 'string';
    if (sign && sign !== true && !Array.isArray(sign))
        sign = [sign];
    const cookieKeys = Object.keys((0, cookie_1.parse)(cookieString));
    for (let i = 0; i < cookieKeys.length; i++) {
        const key = cookieKeys[i];
        let value = (0, cookie_1.parse)(cookieString)[key];
        if (sign === true || sign?.includes(key)) {
            if (!secret)
                throw new Error('No secret is provided to cookie plugin');
            if (isStringKey) {
                // @ts-ignore
                value = await (0, utils_1.unsignCookie)(value, secret);
                // @ts-ignore
                if (value === false)
                    throw new error_1.InvalidCookieSignature(key);
            }
            else {
                let fail = true;
                for (let i = 0; i < secret.length; i++) {
                    const temp = await (0, utils_1.unsignCookie)(value, secret[i]);
                    if (temp !== false) {
                        value = temp;
                        fail = false;
                        break;
                    }
                }
                if (fail)
                    throw new error_1.InvalidCookieSignature(key);
            }
        }
        if (value === undefined)
            continue;
        const start = value.charCodeAt(0);
        if (start === 123 || start === 91)
            try {
                const cookie = new Cookie(JSON.parse(value));
                // @ts-ignore
                cookie.setter = set;
                cookie.name = key;
                jar[key] = cookie;
                continue;
            }
            catch {
                // Not empty
            }
        // @ts-ignore
        if (!Number.isNaN(+value))
            value = +value;
        // @ts-ignore
        else if (value === 'true')
            value = true;
        // @ts-ignore
        else if (value === 'false')
            value = false;
        const cookie = new Cookie(value, properties);
        // @ts-ignore
        cookie.setter = set;
        cookie.name = key;
        jar[key] = cookie;
    }
    return (0, exports.createCookieJar)(jar, set);
};
exports.parseCookie = parseCookie;
