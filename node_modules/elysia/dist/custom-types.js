import{TypeSystem as e}from"@sinclair/typebox/system";import{Type as t,FormatRegistry as i}from"@sinclair/typebox";try{e.Format("email",e=>/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(e)),e.Format("uuid",e=>/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e)),e.Format("date",e=>!Number.isNaN(new Date(e).getTime())),e.Format("date-time",e=>!Number.isNaN(new Date(e).getTime()))}catch(e){// Not empty
}let r=e=>{if("string"==typeof e)switch(e.slice(-1)){case"k":return 1024*+e.slice(0,e.length-1);case"m":return 1048576*+e.slice(0,e.length-1);default:return+e}return e},n=(e,t)=>{if(!(t instanceof Blob)||e.minSize&&t.size<r(e.minSize)||e.maxSize&&t.size>r(e.maxSize))return!1;if(e.extension){if("string"==typeof e.extension){if(!t.type.startsWith(e.extension))return!1}else{for(let i=0;i<e.extension.length;i++)if(t.type.startsWith(e.extension[i]))return!0;return!1}}return!0},a=e.Type("Files",(e,t)=>{if(!Array.isArray(t))return n(e,t);if(e.minItems&&t.length<e.minItems||e.maxItems&&t.length>e.maxItems)return!1;for(let i=0;i<t.length;i++)if(!n(e,t[i]))return!1;return!0});i.Set("numeric",e=>!isNaN(+e)),i.Set("ObjectString",e=>{let t=e.charCodeAt(0);if((9===t||10===t||32===t)&&(t=e.trimStart().charCodeAt(0)),123!==t&&91!==t)return!1;try{return JSON.parse(e),!0}catch{return!1}});export const ElysiaType={Numeric:e=>t.Transform(t.Union([t.String({format:"numeric",default:0}),t.Number(e)])).Decode(e=>{let t=+e;return isNaN(t)?e:t}).Encode(e=>e),ObjectString:(e,i)=>t.Transform(t.Union([t.String({format:"ObjectString",default:""}),t.Object(e,i)])).Decode(e=>{if("string"==typeof e)try{return JSON.parse(e)}catch{}return e}).Encode(e=>JSON.stringify(e)),File:e.Type("File",n),Files:(e={})=>t.Transform(t.Union([a(e)])).Decode(e=>Array.isArray(e)?e:[e]).Encode(e=>e),Nullable:e=>t.Union([t.Null(),e]),/**
	 * Allow Optional, Nullable and Undefined
	 */MaybeEmpty:e=>t.Union([t.Null(),t.Undefined(),e]),Cookie:(e,i)=>t.Object(e,i)};t.ObjectString=ElysiaType.ObjectString,/**
 * A Numeric string
 *
 * Will be parse to Number
 */t.Numeric=ElysiaType.Numeric,t.File=(e={})=>ElysiaType.File({default:"File",...e,extension:e?.type,type:"string",format:"binary"}),t.Files=(e={})=>ElysiaType.Files({...e,elysiaMeta:"Files",default:"Files",extension:e?.type,type:"array",items:{...e,default:"Files",type:"string",format:"binary"}}),t.Nullable=e=>ElysiaType.Nullable(e),t.MaybeEmpty=ElysiaType.MaybeEmpty,t.Cookie=ElysiaType.Cookie;export{t as t};// type Template =
// 	| string
// 	| number
// 	| bigint
// 	| boolean
// 	| StringConstructor
// 	| NumberConstructor
// 	| undefined
// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>
// 	? (
// 			First extends Readonly<Template[]>
// 				? First[number]
// 				: First extends StringConstructor
// 				? string
// 				: First extends NumberConstructor
// 				? `${number}`
// 				: First
// 	  ) extends infer A
// 		? Rest extends []
// 			? A extends undefined
// 				? NonNullable<A> | ''
// 				: A
// 			: // @ts-ignore
// 			A extends undefined
// 			? `${NonNullable<A>}${Join<Rest>}` | ''
// 			: // @ts-ignore
// 			  `${A}${Join<Rest>}`
// 		: ''
// 	: ''
// const template = <
// 	const T extends Readonly<(Template | Readonly<Template[]>)[]>
// >(
// 	...p: T
// ): Join<T> => {
// 	return a as any
// }
// const create =
// 	<const T extends string>(t: T): ((t: T) => void) =>
// 	(t) =>
// 		t
// const optional = <
// 	const T extends Readonly<(Template | Readonly<Template[]>)[]>
// >(
// 	...p: T
// ): T | undefined => {
// 	return undefined
// }
// template.optional = optional
// const hi = create(
// 	template(
// 		['seminar', 'millennium'],
// 		':',
// 		['Rio', 'Yuuka', 'Noa', 'Koyuki'],
// 		template.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),
// 		template.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),
// 		template.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))
// 	)
// )
// hi(`seminar:Noa,Koyuki,Yuuka`)
// const a = TypeCompiler.Compile(Type.String())
// console.log(v.Decode.toString())
// const T = Type.Transform(v.schema)
// 	.Decode((value) => new Date(value)) // required: number to Date
// 	.Encode((value) => value.getTime()) // required: Date to number
// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)
// const encoded = Value.Encode(T, decoded)
